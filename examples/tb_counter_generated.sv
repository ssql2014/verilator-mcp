// Testbench for counter
// Generated by Verilator MCP
// Template: basic
// Stimulus Type: directed

`timescale 1ns/1ps

module tb_counter();

  // Testbench signals
  reg clk;
  reg rst_n;
  reg enable;
  reg clear;
  wire [7:0] count;
  wire overflow;

  // Testbench control
  integer error_count = 0;
  integer test_count = 0;

  // DUT instantiation
  counter dut (
    .clk(clk),
    .rst_n(rst_n),
    .enable(enable),
    .clear(clear),
    .count(count),
    .overflow(overflow)
  );

  // Clock generation
  initial clk = 0;
  always #(5) clk = ~clk;

  // Reset sequence
  initial begin
    rst_n = 0;
    #100;
    rst_n = 1;
  end

  // Stimulus generation
  initial begin
    // Wait for reset
    #110;

    // Directed test cases
    // Test case 1
    enable = 0;
    clear = 0;
    #100;
    test_count++;

    // Test case 2
    enable = 1;
    clear = 1;
    #100;
    test_count++;

    // Test case 3
    enable = 0;
    clear = 0;
    #100;
    test_count++;

    // Test case 4
    enable = 1;
    clear = 1;
    #100;
    test_count++;

    // Test case 5
    enable = 0;
    clear = 0;
    #100;
    test_count++;


    // End simulation
    #10000;
    $display("Simulation completed. Errors: %d, Tests: %d", error_count, test_count);
    $finish;
  end

  // Response checking
  always @(posedge clk) begin
    // Add your checking logic here
    // Example: if (output !== expected) error_count++;
  end

  // Assertions
  // Check that count is never X or Z
  assert property (@(posedge clk) 
    !$isunknown(count)
  ) else $error("count is X or Z");

  // Check that overflow is never X or Z
  assert property (@(posedge clk) 
    !$isunknown(overflow)
  ) else $error("overflow is X or Z");

  // Coverage
  covergroup cg @(posedge clk);
    enable_cp: coverpoint enable;
    clear_cp: coverpoint clear;
  endgroup

  cg cg_inst = new();

  // Waveform dumping
  initial begin
    $dumpfile("tb_counter.vcd");
    $dumpvars(0, tb_counter);
  end

endmodule
